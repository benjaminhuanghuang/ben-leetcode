/*
928. Minimize Malware Spread II [hard]

https://leetcode.com/problems/minimize-malware-spread-ii/
*/

#include <vector>
#include <unordered_set>
#include <unordered_map>

#include "common/DSU.h"

using namespace std;

/*
https://leetcode.com/problems/minimize-malware-spread-ii/solution/
有一个无向图，图中有些结点被感染了，感染会通过图的边传播。现在可以移除一个初始被感染的结点（是移除，而不是让它不被感染），问移除哪一个结点可以使最终被感染的总结点数最小？如果有多个结点，输出编号最小的一个。

Union find
*/

class Solution
{
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
  {
    int N = graph.size();
    DSU dsu(N);

    // clean[u] == 1 if its a node in the graph not in initial.
    vector<int> clean(N, 1);
    for (int x : initial)
      clean[x] = 0;

    for (int u = 0; u < N; ++u)
      if (clean[u] == 1)
        for (int v = 0; v < N; ++v)
          if (clean[v] == 1)
            if (graph[u][v] == 1)
              dsu.Union(u, v);

    // dsu now represents the components of the graph without
    // any nodes from initial.  Let's call this graph G.
    vector<int> count;
    unordered_map<int, unordered_set<int>> nodeToCompo;
    for (int u : initial)
    {
      unordered_set<int> components;
      for (int v = 0; v < N; ++v)
        if (clean[v] == 1)
        {
          if (graph[u][v] == 1)
            components.insert(dsu.Find(v));
        }

      nodeToCompo[u] = components;
      for (int c : components)
        count[c]++;
    }

    // For each node u in initial, nodeToCompo.get(u)
    // now has every component from G that u neighbors.

    int ans = -1, ansSize = -1;
    for (const auto &kv : nodeToCompo)
    {
      unordered_set<int> components = kv.second;
      int score = 0;
      //---??????
      // for (int c : components)
      //   if (count[c] == 1) // uniquely infected
      //     score += dsu.size(c);

      if (score > ansSize || score == ansSize && kv.first < ans)
      {
        ansSize = score;
        ans = kv.first;
      }
    }

    return ans;
  }
};

/*
  DFS
  https://www.bilibili.com/video/av49549444?from=search&seid=11667938017961185995
  https://www.youtube.com/watch?v=aiRGht4MKx0
  https://github.com/happygirlzt/LeetCode/blob/master/Java/MinimizeMalwareSpread2.java
*/
class Solution_DFS
{
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
  {
    sort(initial.begin(), initial.end());
    int n = graph.size();
    unordered_set<int> mal;
    for (int i : initial)
    {
      mal.insert(i);
    }

    int num = -1;
    int res = -1;
    for (int i : initial)
    {
      unordered_set<int> visited;
      visited.insert(i);
      int save = 0;
      for (int j = 0; j < n; j++)
      {
        if (i != j && graph[i][j] == 1)
        {
          int tmp = dfs(j, visited, mal, graph);
          if (tmp < 0)
            continue;
          save += tmp;
        }
      }

      if (save > num)
      {
        num = save;
        res = i;
      }
    }

    return res;
  }

private:
  int dfs(int node, unordered_set<int> &visited, unordered_set<int> &mal, vector<vector<int>> &graph)
  {
    auto ret = visited.insert(node);
    if(!ret.second)
      return 0;

    if (mal.count(node))
      return -1;

    int saved = 1;
    for (int j = 0; j < graph.size(); j++)
    {
      if (node != j && graph[node][j] == 1)
      {
        int tmp = dfs(j, visited, mal, graph);
        if (tmp < 0)
        {
          mal.insert(node);
          return -1;
        }

        saved += tmp;
      }
    }

    return saved;
  }
};